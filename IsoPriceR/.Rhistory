# We blend the new particles with the old ones
# new_cloud <- rbind(new_cloud[s, ], cloud[selected_indices, ][ !s,])
# new_cloud <- new_cloud[(logd_independent_priors(model_prior, new_cloud) != - Inf) &
#                          (predict(kde, x = new_cloud[, random_parms]) >0 ), , drop = FALSE]
new_cloud <- new_cloud[logd_independent_priors(model_prior, new_cloud) != - Inf, , drop = FALSE]
if(nrow(new_cloud) >0){
X <- sample_X(l_m , new_cloud, R = MC_R)
pp_fake <- compute_pure_premia(X, coverage_type = "xs", ths_premium)
ds1 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax(cps - pp_fake[,k] /sp_bounds[1], 0) )^2)))
ds2 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax( pp_fake[,k] / sp_bounds[2] - cps , 0) )^2)))
ress_iso <- lapply(1:ncol(pp_fake), function(k) isoreg(pp_fake[, k], cps))
fs <- lapply(ress_iso, function(res_iso) stepfun(sort(res_iso$x), c(min(res_iso$yf) /2 ,
res_iso$yf), f = 1))
ds_temp <- sapply(1:nrow(new_cloud), function(k) mean((fs[[k]](pp_fake[, k]) - data$x)^2)^(1/2)) + ds1 + ds2
cloud <- rbind(cloud, new_cloud[ds_temp < sample_res$eps, ])
ds <- c(ds, ds_temp[ds_temp < max(sample_res$eps, 10^(-8))])
}else{
cloud <- cloud; ds <- ds
}
utils::setTxtProgressBar(pb,nrow(cloud))
}
close(pb)
prior_prob <- exp(logd_independent_priors(model_prior, cloud))
# kde <- ks::kde(x = old_cloud[indices, random_parms],
#                H =  2 * w.cov[random_parms,random_parms],
#                eval.points = cloud[, random_parms],
#                w = w[indices])
# inter_prob <- kde$estimate
inter_prob <- ks::dmvnorm.mixt(cloud[, random_parms],
mus = old_cloud[indices, random_parms],
Sigmas=matrix(rep(2 * w.cov[random_parms,random_parms], length(indices)), ncol = length(random_parms), byrow = TRUE),
props = w[indices] / sum(w[indices]))
w <- (prior_prob / inter_prob)
# w[is.infinite(w)] <- 0
w <- w / sum(w)
# w.cov <- tryCatch(
#   {
#     cov.wt(cloud[, l_m$parm_names], wt = w, cor = FALSE, center = TRUE)$cov
#   },
#   error = function(e) {
#     browser()
#   }
# )
w.cov <- cov.wt(cloud[, l_m$parm_names], wt = w, cor = FALSE, center = TRUE)$cov
sort_index <- order(ds)
ESSs <- sapply(1:length(w), function(k) 1 / sum((w[sort_index][1:k] / sum(w[sort_index][1:k]))^2) )
if(sum(ESSs > popSize / 2) == 0){
indices <- sort_index
}else{
indices <- sort_index[1:which(ESSs > popSize/2)[1]]
}
eps <- max(ds[indices])
# kde <- suppressWarnings(
#   ks::kde(x = cloud[indices, random_parms], H =  2 * w.cov[random_parms,random_parms],
#           # eval.points = cloud[indices, random_parms] ,
#           w = w[indices]))
return(list(cloud = cloud, ds = ds, indices = indices, eps = max(ds[indices]), ESS = sum(w[indices])^2/sum(w[indices]^2), w = w, w.cov = w.cov))
}
g<- 1; Epss <- c(Inf); ESS <- c(popSize)
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_first(data, model_prior, l_m, p_p, popSize, MC_R, sp_bounds)
Clouds <- list(sample_res$cloud); dss <- list(sample_res$ds)
g <- 2
Epss[g] <- sample_res$eps; ESS[g] <- sample_res$ESS
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_g(data, model_prior, l_m, p_p, popSize, sample_res, MC_R, sp_bounds)
Clouds[[g]] <- sample_res$cloud; dss[[g]] <- sample_res$ds
while( (Epss[g-1] - Epss[g] > acc) | (Epss[g] > eps_min)){
g <- g + 1
Epss[g] <- sample_res$eps; ESS[g] <- sample_res$ESS
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_g(data, model_prior, l_m, p_p, popSize, sample_res, MC_R, sp_bounds)
Clouds[[g]] <- sample_res$cloud; dss[[g]] <- sample_res$ds
}
g<- 1; Epss <- c(Inf); ESS <- c(popSize)
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_first(data, model_prior, l_m, p_p, popSize, MC_R, sp_bounds)
Clouds <- list(sample_res$cloud); dss <- list(sample_res$ds)
g <- 2
Epss[g] <- sample_res$eps; ESS[g] <- sample_res$ESS
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_g(data, model_prior, l_m, p_p, popSize, sample_res, MC_R, sp_bounds)
Clouds[[g]] <- sample_res$cloud; dss[[g]] <- sample_res$ds
g <- g + 1
Epss[g] <- sample_res$eps; ESS[g] <- sample_res$ESS
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
# premium parameter as a matrix
ths_premium <- as.matrix(data[p_p$parm_names]); premium_type <- p_p$premium_type
cps <- data$x
# which parameters are random (to be infered)
random_parms <- l_m$parm_names[sapply(1:length(model_prior$prior_distributions),
function(k) model_prior$prior_distributions[[k]]$dist_name != "constant")]
old_cloud <- sample_res$cloud[, l_m$parm_names]; indices <- sample_res$indices; w <- sample_res$w
eps <- sample_res$eps ; w.cov <- sample_res$w.cov
cloud <- matrix(nrow = 0, ncol = ncol(old_cloud)); ds <- c()
selected_indices <- sample(indices, size = popSize - nrow(cloud), replace = T, prob = w[indices])
new_cloud <- old_cloud[selected_indices, , drop = FALSE] + mvtnorm::rmvnorm(n = popSize - nrow(cloud),
mean = rep(0,length(model_prior$parms_name)),
sigma = 2 * w.cov)
# We blend the new particles with the old ones
# new_cloud <- rbind(new_cloud[s, ], cloud[selected_indices, ][ !s,])
# new_cloud <- new_cloud[(logd_independent_priors(model_prior, new_cloud) != - Inf) &
#                          (predict(kde, x = new_cloud[, random_parms]) >0 ), , drop = FALSE]
new_cloud <- new_cloud[logd_independent_priors(model_prior, new_cloud) != - Inf, , drop = FALSE]
new_cloud
X <- sample_X(l_m , new_cloud, R = MC_R)
pp_fake <- compute_pure_premia(X, coverage_type = "xs", ths_premium)
ds1 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax(cps - pp_fake[,k] /sp_bounds[1], 0) )^2)))
ds2 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax( pp_fake[,k] / sp_bounds[2] - cps , 0) )^2)))
ress_iso <- lapply(1:ncol(pp_fake), function(k) isoreg(pp_fake[, k], cps))
fs <- lapply(ress_iso, function(res_iso) stepfun(sort(res_iso$x), c(min(res_iso$yf) /2 ,
res_iso$yf), f = 1))
ds_temp <- sapply(1:nrow(new_cloud), function(k) mean((fs[[k]](pp_fake[, k]) - data$x)^2)^(1/2)) + ds1 + ds2
ds_temp
cloud <- rbind(cloud, new_cloud[ds_temp < sample_res$eps, ])
ds <- c(ds, ds_temp[ds_temp < max(sample_res$eps, 10^(-8))])
ds
ds_temp < max(sample_res$eps, 10^(-8))
if(nrow(new_cloud) >0){
X <- sample_X(l_m , new_cloud, R = MC_R)
pp_fake <- compute_pure_premia(X, coverage_type = "xs", ths_premium)
ds1 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax(cps - pp_fake[,k] /sp_bounds[1], 0) )^2)))
ds2 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax( pp_fake[,k] / sp_bounds[2] - cps , 0) )^2)))
ress_iso <- lapply(1:ncol(pp_fake), function(k) isoreg(pp_fake[, k], cps))
fs <- lapply(ress_iso, function(res_iso) stepfun(sort(res_iso$x), c(min(res_iso$yf) /2 ,
res_iso$yf), f = 1))
ds_temp <- sapply(1:nrow(new_cloud), function(k) mean((fs[[k]](pp_fake[, k]) - data$x)^2)^(1/2)) + ds1 + ds2
cloud <- rbind(cloud, new_cloud[ds_temp < sample_res$eps, ])
ds <- c(ds, ds_temp[ds_temp < max(sample_res$eps, 10^(-8))])
}else{
cloud <- cloud; ds <- ds
}
utils::setTxtProgressBar(pb,nrow(cloud))
# premium parameter as a matrix
ths_premium <- as.matrix(data[p_p$parm_names]); premium_type <- p_p$premium_type
cps <- data$x
# which parameters are random (to be infered)
random_parms <- l_m$parm_names[sapply(1:length(model_prior$prior_distributions),
function(k) model_prior$prior_distributions[[k]]$dist_name != "constant")]
old_cloud <- sample_res$cloud[, l_m$parm_names]; indices <- sample_res$indices; w <- sample_res$w
eps <- sample_res$eps ; w.cov <- sample_res$w.cov
cloud <- matrix(nrow = 0, ncol = ncol(old_cloud)); ds <- c()
pb = utils::txtProgressBar(min = 0, max = popSize, initial = 0)
while(nrow(cloud) < popSize){
selected_indices <- sample(indices, size = popSize - nrow(cloud), replace = T, prob = w[indices])
new_cloud <- old_cloud[selected_indices, , drop = FALSE] + mvtnorm::rmvnorm(n = popSize - nrow(cloud),
mean = rep(0,length(model_prior$parms_name)),
sigma = 2 * w.cov)
# We blend the new particles with the old ones
# new_cloud <- rbind(new_cloud[s, ], cloud[selected_indices, ][ !s,])
# new_cloud <- new_cloud[(logd_independent_priors(model_prior, new_cloud) != - Inf) &
#                          (predict(kde, x = new_cloud[, random_parms]) >0 ), , drop = FALSE]
new_cloud <- new_cloud[logd_independent_priors(model_prior, new_cloud) != - Inf, , drop = FALSE]
if(nrow(new_cloud) >0){
X <- sample_X(l_m , new_cloud, R = MC_R)
pp_fake <- compute_pure_premia(X, coverage_type = "xs", ths_premium)
ds1 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax(cps - pp_fake[,k] /sp_bounds[1], 0) )^2)))
ds2 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax( pp_fake[,k] / sp_bounds[2] - cps , 0) )^2)))
ress_iso <- lapply(1:ncol(pp_fake), function(k) isoreg(pp_fake[, k], cps))
fs <- lapply(ress_iso, function(res_iso) stepfun(sort(res_iso$x), c(min(res_iso$yf) /2 ,
res_iso$yf), f = 1))
ds_temp <- sapply(1:nrow(new_cloud), function(k) mean((fs[[k]](pp_fake[, k]) - data$x)^2)^(1/2)) + ds1 + ds2
cloud <- rbind(cloud, new_cloud[ds_temp < sample_res$eps, ])
ds <- c(ds, ds_temp[ds_temp < max(sample_res$eps, 10^(-8))])
}else{
cloud <- cloud; ds <- ds
}
utils::setTxtProgressBar(pb,nrow(cloud))
}
#' @return A list containing the initial cloud,
#' the distance wrt the real data,
#' the indices of the particles to be retained to build the next cloud of particles
#' the tolerance level, the Effective Sample Size, the KDE estimator to represent the particles distribution
#' the weights of each particles and the empirical variance-covariance matrix.
#'
#' @return
#' @export
#'
#' @examples
sample_g <- function(data, model_prior, l_m, p_p, popSize, sample_res, MC_R, sp_bounds){
# premium parameter as a matrix
ths_premium <- as.matrix(data[p_p$parm_names]); premium_type <- p_p$premium_type
cps <- data$x
# which parameters are random (to be infered)
random_parms <- l_m$parm_names[sapply(1:length(model_prior$prior_distributions),
function(k) model_prior$prior_distributions[[k]]$dist_name != "constant")]
old_cloud <- sample_res$cloud[, l_m$parm_names]; indices <- sample_res$indices; w <- sample_res$w
eps <- sample_res$eps ; w.cov <- sample_res$w.cov
cloud <- matrix(nrow = 0, ncol = ncol(old_cloud)); ds <- c()
pb = utils::txtProgressBar(min = 0, max = popSize, initial = 0)
while(nrow(cloud) < popSize){
selected_indices <- sample(indices, size = popSize - nrow(cloud), replace = T, prob = w[indices])
new_cloud <- old_cloud[selected_indices, , drop = FALSE] + mvtnorm::rmvnorm(n = popSize - nrow(cloud),
mean = rep(0,length(model_prior$parms_name)),
sigma = 2 * w.cov)
# We blend the new particles with the old ones
# new_cloud <- rbind(new_cloud[s, ], cloud[selected_indices, ][ !s,])
# new_cloud <- new_cloud[(logd_independent_priors(model_prior, new_cloud) != - Inf) &
#                          (predict(kde, x = new_cloud[, random_parms]) >0 ), , drop = FALSE]
new_cloud <- new_cloud[logd_independent_priors(model_prior, new_cloud) != - Inf, , drop = FALSE]
if(nrow(new_cloud) >0){
X <- sample_X(l_m , new_cloud, R = MC_R)
pp_fake <- compute_pure_premia(X, coverage_type = "xs", ths_premium)
ds1 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax(cps - pp_fake[,k] /sp_bounds[1], 0) )^2)))
ds2 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax( pp_fake[,k] / sp_bounds[2] - cps , 0) )^2)))
ress_iso <- lapply(1:ncol(pp_fake), function(k) isoreg(pp_fake[, k], cps))
fs <- lapply(ress_iso, function(res_iso) stepfun(sort(res_iso$x), c(min(res_iso$yf) /2 ,
res_iso$yf), f = 1))
ds_temp <- sapply(1:nrow(new_cloud), function(k) mean((fs[[k]](pp_fake[, k]) - data$x)^2)^(1/2)) + ds1 + ds2
cloud <- rbind(cloud, new_cloud[max(sample_res$eps, 10^(-8)), ])
ds <- c(ds, ds_temp[ds_temp < max(sample_res$eps, 10^(-8))])
}else{
cloud <- cloud; ds <- ds
}
utils::setTxtProgressBar(pb,nrow(cloud))
}
close(pb)
prior_prob <- exp(logd_independent_priors(model_prior, cloud))
# kde <- ks::kde(x = old_cloud[indices, random_parms],
#                H =  2 * w.cov[random_parms,random_parms],
#                eval.points = cloud[, random_parms],
#                w = w[indices])
# inter_prob <- kde$estimate
inter_prob <- ks::dmvnorm.mixt(cloud[, random_parms],
mus = old_cloud[indices, random_parms],
Sigmas=matrix(rep(2 * w.cov[random_parms,random_parms], length(indices)), ncol = length(random_parms), byrow = TRUE),
props = w[indices] / sum(w[indices]))
w <- (prior_prob / inter_prob)
# w[is.infinite(w)] <- 0
w <- w / sum(w)
# w.cov <- tryCatch(
#   {
#     cov.wt(cloud[, l_m$parm_names], wt = w, cor = FALSE, center = TRUE)$cov
#   },
#   error = function(e) {
#     browser()
#   }
# )
w.cov <- cov.wt(cloud[, l_m$parm_names], wt = w, cor = FALSE, center = TRUE)$cov
sort_index <- order(ds)
ESSs <- sapply(1:length(w), function(k) 1 / sum((w[sort_index][1:k] / sum(w[sort_index][1:k]))^2) )
if(sum(ESSs > popSize / 2) == 0){
indices <- sort_index
}else{
indices <- sort_index[1:which(ESSs > popSize/2)[1]]
}
eps <- max(ds[indices])
# kde <- suppressWarnings(
#   ks::kde(x = cloud[indices, random_parms], H =  2 * w.cov[random_parms,random_parms],
#           # eval.points = cloud[indices, random_parms] ,
#           w = w[indices]))
return(list(cloud = cloud, ds = ds, indices = indices, eps = max(ds[indices]), ESS = sum(w[indices])^2/sum(w[indices]^2), w = w, w.cov = w.cov))
}
g<- 1; Epss <- c(Inf); ESS <- c(popSize)
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_first(data, model_prior, l_m, p_p, popSize, MC_R, sp_bounds)
Clouds <- list(sample_res$cloud); dss <- list(sample_res$ds)
g <- 2
Epss[g] <- sample_res$eps; ESS[g] <- sample_res$ESS
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_g(data, model_prior, l_m, p_p, popSize, sample_res, MC_R, sp_bounds)
g<- 1; Epss <- c(Inf); ESS <- c(popSize)
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_first(data, model_prior, l_m, p_p, popSize, MC_R, sp_bounds)
Clouds <- list(sample_res$cloud); dss <- list(sample_res$ds)
g <- 2
Epss[g] <- sample_res$eps; ESS[g] <- sample_res$ESS
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
# premium parameter as a matrix
ths_premium <- as.matrix(data[p_p$parm_names]); premium_type <- p_p$premium_type
cps <- data$x
# which parameters are random (to be infered)
random_parms <- l_m$parm_names[sapply(1:length(model_prior$prior_distributions),
function(k) model_prior$prior_distributions[[k]]$dist_name != "constant")]
old_cloud <- sample_res$cloud[, l_m$parm_names]; indices <- sample_res$indices; w <- sample_res$w
eps <- sample_res$eps ; w.cov <- sample_res$w.cov
cloud <- matrix(nrow = 0, ncol = ncol(old_cloud)); ds <- c()
pb = utils::txtProgressBar(min = 0, max = popSize, initial = 0)
selected_indices <- sample(indices, size = popSize - nrow(cloud), replace = T, prob = w[indices])
new_cloud <- old_cloud[selected_indices, , drop = FALSE] + mvtnorm::rmvnorm(n = popSize - nrow(cloud),
mean = rep(0,length(model_prior$parms_name)),
sigma = 2 * w.cov)
# We blend the new particles with the old ones
# new_cloud <- rbind(new_cloud[s, ], cloud[selected_indices, ][ !s,])
# new_cloud <- new_cloud[(logd_independent_priors(model_prior, new_cloud) != - Inf) &
#                          (predict(kde, x = new_cloud[, random_parms]) >0 ), , drop = FALSE]
new_cloud <- new_cloud[logd_independent_priors(model_prior, new_cloud) != - Inf, , drop = FALSE]
if(nrow(new_cloud) >0){
X <- sample_X(l_m , new_cloud, R = MC_R)
pp_fake <- compute_pure_premia(X, coverage_type = "xs", ths_premium)
ds1 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax(cps - pp_fake[,k] /sp_bounds[1], 0) )^2)))
ds2 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax( pp_fake[,k] / sp_bounds[2] - cps , 0) )^2)))
ress_iso <- lapply(1:ncol(pp_fake), function(k) isoreg(pp_fake[, k], cps))
fs <- lapply(ress_iso, function(res_iso) stepfun(sort(res_iso$x), c(min(res_iso$yf) /2 ,
res_iso$yf), f = 1))
ds_temp <- sapply(1:nrow(new_cloud), function(k) mean((fs[[k]](pp_fake[, k]) - data$x)^2)^(1/2)) + ds1 + ds2
cloud <- rbind(cloud, new_cloud[max(sample_res$eps, 10^(-8)), ])
ds <- c(ds, ds_temp[ds_temp < max(sample_res$eps, 10^(-8))])
}else{
cloud <- cloud; ds <- ds
}
cloud
sample_res$eps
#' @return A list containing the initial cloud,
#' the distance wrt the real data,
#' the indices of the particles to be retained to build the next cloud of particles
#' the tolerance level, the Effective Sample Size, the KDE estimator to represent the particles distribution
#' the weights of each particles and the empirical variance-covariance matrix.
#'
#' @return
#' @export
#'
#' @examples
sample_g <- function(data, model_prior, l_m, p_p, popSize, sample_res, MC_R, sp_bounds){
# premium parameter as a matrix
ths_premium <- as.matrix(data[p_p$parm_names]); premium_type <- p_p$premium_type
cps <- data$x
# which parameters are random (to be infered)
random_parms <- l_m$parm_names[sapply(1:length(model_prior$prior_distributions),
function(k) model_prior$prior_distributions[[k]]$dist_name != "constant")]
old_cloud <- sample_res$cloud[, l_m$parm_names]; indices <- sample_res$indices; w <- sample_res$w
eps <- sample_res$eps ; w.cov <- sample_res$w.cov
cloud <- matrix(nrow = 0, ncol = ncol(old_cloud)); ds <- c()
pb = utils::txtProgressBar(min = 0, max = popSize, initial = 0)
while(nrow(cloud) < popSize){
selected_indices <- sample(indices, size = popSize - nrow(cloud), replace = T, prob = w[indices])
new_cloud <- old_cloud[selected_indices, , drop = FALSE] + mvtnorm::rmvnorm(n = popSize - nrow(cloud),
mean = rep(0,length(model_prior$parms_name)),
sigma = 2 * w.cov)
# We blend the new particles with the old ones
# new_cloud <- rbind(new_cloud[s, ], cloud[selected_indices, ][ !s,])
# new_cloud <- new_cloud[(logd_independent_priors(model_prior, new_cloud) != - Inf) &
#                          (predict(kde, x = new_cloud[, random_parms]) >0 ), , drop = FALSE]
new_cloud <- new_cloud[logd_independent_priors(model_prior, new_cloud) != - Inf, , drop = FALSE]
if(nrow(new_cloud) >0){
X <- sample_X(l_m , new_cloud, R = MC_R)
pp_fake <- compute_pure_premia(X, coverage_type = "xs", ths_premium)
ds1 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax(cps - pp_fake[,k] /sp_bounds[1], 0) )^2)))
ds2 <- sapply(1:ncol(pp_fake), function(k) sqrt(mean((pmax( pp_fake[,k] / sp_bounds[2] - cps , 0) )^2)))
ress_iso <- lapply(1:ncol(pp_fake), function(k) isoreg(pp_fake[, k], cps))
fs <- lapply(ress_iso, function(res_iso) stepfun(sort(res_iso$x), c(min(res_iso$yf) /2 ,
res_iso$yf), f = 1))
ds_temp <- sapply(1:nrow(new_cloud), function(k) mean((fs[[k]](pp_fake[, k]) - data$x)^2)^(1/2)) + ds1 + ds2
cloud <- rbind(cloud, new_cloud[ds_temp < max(sample_res$eps, 10^(-8)), ])
ds <- c(ds, ds_temp[ds_temp < max(sample_res$eps, 10^(-8))])
}else{
cloud <- cloud; ds <- ds
}
utils::setTxtProgressBar(pb,nrow(cloud))
}
close(pb)
prior_prob <- exp(logd_independent_priors(model_prior, cloud))
# kde <- ks::kde(x = old_cloud[indices, random_parms],
#                H =  2 * w.cov[random_parms,random_parms],
#                eval.points = cloud[, random_parms],
#                w = w[indices])
# inter_prob <- kde$estimate
inter_prob <- ks::dmvnorm.mixt(cloud[, random_parms],
mus = old_cloud[indices, random_parms],
Sigmas=matrix(rep(2 * w.cov[random_parms,random_parms], length(indices)), ncol = length(random_parms), byrow = TRUE),
props = w[indices] / sum(w[indices]))
w <- (prior_prob / inter_prob)
# w[is.infinite(w)] <- 0
w <- w / sum(w)
# w.cov <- tryCatch(
#   {
#     cov.wt(cloud[, l_m$parm_names], wt = w, cor = FALSE, center = TRUE)$cov
#   },
#   error = function(e) {
#     browser()
#   }
# )
w.cov <- cov.wt(cloud[, l_m$parm_names], wt = w, cor = FALSE, center = TRUE)$cov
sort_index <- order(ds)
ESSs <- sapply(1:length(w), function(k) 1 / sum((w[sort_index][1:k] / sum(w[sort_index][1:k]))^2) )
if(sum(ESSs > popSize / 2) == 0){
indices <- sort_index
}else{
indices <- sort_index[1:which(ESSs > popSize/2)[1]]
}
eps <- max(ds[indices])
# kde <- suppressWarnings(
#   ks::kde(x = cloud[indices, random_parms], H =  2 * w.cov[random_parms,random_parms],
#           # eval.points = cloud[indices, random_parms] ,
#           w = w[indices]))
return(list(cloud = cloud, ds = ds, indices = indices, eps = max(ds[indices]), ESS = sum(w[indices])^2/sum(w[indices]^2), w = w, w.cov = w.cov))
}
g<- 1; Epss <- c(Inf); ESS <- c(popSize)
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_first(data, model_prior, l_m, p_p, popSize, MC_R, sp_bounds)
Clouds <- list(sample_res$cloud); dss <- list(sample_res$ds)
g <- 2
Epss[g] <- sample_res$eps; ESS[g] <- sample_res$ESS
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_g(data, model_prior, l_m, p_p, popSize, sample_res, MC_R, sp_bounds)
Clouds[[g]] <- sample_res$cloud; dss[[g]] <- sample_res$ds
while( (Epss[g-1] - Epss[g] > acc) | (Epss[g] > eps_min)){
g <- g + 1
Epss[g] <- sample_res$eps; ESS[g] <- sample_res$ESS
print(paste("Sampling generation of particles ", g, "; eps = ", Epss[g], "; ESS = ", ESS[g]))
sample_res <- sample_g(data, model_prior, l_m, p_p, popSize, sample_res, MC_R, sp_bounds)
Clouds[[g]] <- sample_res$cloud; dss[[g]] <- sample_res$ds
}
knitr::opts_chunk$set(echo = TRUE)
library(latex2exp)
library(IsoPriceR)
library(ggplot2)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
set.seed(142)
# Loss model
freq_dist <- model("poisson", c("lambda"))
sev_dist <- model("lognormal", c("mu", "sigma"))
l_m <- loss_model(freq_dist, sev_dist, "Poisson-Lognormal")
# True parameter
lambda_true <- 3; mu_true <- 0; sigma_true <- 1
true_parms <- t(as.matrix(c(lambda_true, mu_true, sigma_true)))
colnames(true_parms) <- l_m$parm_names
# Data
## Sample of claim data to calculate the true pure premium via Monte Carlo
X_true <- sample_X(l_m, true_parms, R = 10000)
summary(X_true)
## Characteristics of the pure premium which depends on the parameter of the insurance coverage
p_p <- pure_premium("xs", c("r", "d", "l"))
## Random premium parameters
n <- 3; r <- c(0.75, 1, 1); d <- c(0, 1.8, 0); l <- c(Inf, Inf, 6)
## Data frame with the insurance coverage parameters and the pure premium
th_premium <- matrix(c(r, d, l), nrow = n)
pps <- compute_pure_premia(X_true, coverage_type = "xs", th_premium)
df_pp <- data.frame(r = r, d = d, l = l, pp=pps)
df_pp
# Prior settings for the parameters
prior_lambda <- prior_dist("uniform", "lambda",c(0, 5))
prior_mu <- prior_dist("constant", "mu",c(0))
prior_sigma <- prior_dist("uniform", "sigma", c(0, 2))
prior_distributions <- list(prior_lambda, prior_mu, prior_sigma)
model_prior <- independent_priors(prior_distributions)
# Settings for the abc algorithm
popSize <- 500;  MC_R<- 500; acc <- 0.001; sp_bounds <- c(0.00001, 1000000)
data <- df_pp[,c("r", "d", "l")]
data["x"] <- df_pp$pp
res_abc <- abc(data, model_prior, l_m, p_p, popSize, MC_R, acc, sp_bounds, eps_min = 0.01)
# We retrieve the cloud of particles associated to each generation
cloud_dfs <- lapply(res_abc$Clouds, as.data.frame)
cloud_df <- do.call(rbind, cloud_dfs)
cloud_df$generation <- sort(rep(1:length(res_abc$Clouds), popSize))
cloud_df_plot <- rbind(
data.frame(parm = cloud_df$lambda, parm_name = "lambda", generation = cloud_df$generation),
data.frame(parm = cloud_df$sigma, parm_name = "sigma", generation = cloud_df$generation)
)
cloud_df_plot$parm_name <-as.factor(cloud_df_plot$parm_name)
levels(cloud_df_plot$parm_name) <- c(lambda = TeX("$\\lambda$"), sigma = TeX("$\\sigma$"))
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=lambda, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\lambda$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,1]), color="black",
linetype="dashed")
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=mu, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\mu$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,2]), color="black",
linetype="dashed")
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=sigma, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\sigma$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,3]), color="black",
linetype="dashed")
# Prior settings for the parameters
prior_lambda <- prior_dist("uniform", "lambda",c(0, 5))
prior_mu <- prior_dist("constant", "mu",c(0))
prior_sigma <- prior_dist("uniform", "sigma", c(0, 2))
prior_distributions <- list(prior_lambda, prior_mu, prior_sigma)
model_prior <- independent_priors(prior_distributions)
# Settings for the abc algorithm
popSize <- 500;  MC_R<- 500; acc <- 0.001; sp_bounds <- c(0.8, 1.2)
data <- df_pp[,c("r", "d", "l")]
data["x"] <- df_pp$pp
res_abc <- abc(data, model_prior, l_m, p_p, popSize, MC_R, acc, sp_bounds, eps_min = 0.01)
# We retrieve the cloud of particles associated to each generation
cloud_dfs <- lapply(res_abc$Clouds, as.data.frame)
cloud_df <- do.call(rbind, cloud_dfs)
cloud_df$generation <- sort(rep(1:length(res_abc$Clouds), popSize))
cloud_df_plot <- rbind(
data.frame(parm = cloud_df$lambda, parm_name = "lambda", generation = cloud_df$generation),
data.frame(parm = cloud_df$sigma, parm_name = "sigma", generation = cloud_df$generation)
)
cloud_df_plot$parm_name <-as.factor(cloud_df_plot$parm_name)
levels(cloud_df_plot$parm_name) <- c(lambda = TeX("$\\lambda$"), sigma = TeX("$\\sigma$"))
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=lambda, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\lambda$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,1]), color="black",
linetype="dashed")
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=mu, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\mu$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,2]), color="black",
linetype="dashed")
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=sigma, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\sigma$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,3]), color="black",
linetype="dashed")
# Prior settings for the parameters
prior_lambda <- prior_dist("uniform", "lambda",c(0, 5))
prior_mu <- prior_dist("uniform", "mu",c(-3,3))
prior_sigma <- prior_dist("uniform", "sigma", c(0, 2))
prior_distributions <- list(prior_lambda, prior_mu, prior_sigma)
model_prior <- independent_priors(prior_distributions)
# Settings for the abc algorithm
popSize <- 500;  MC_R<- 500; acc <- 0.001; sp_bounds <- c(0.8, 1.2)
data <- df_pp[,c("r", "d", "l")]
data["x"] <- df_pp$pp
res_abc <- abc(data, model_prior, l_m, p_p, popSize, MC_R, acc, sp_bounds, eps_min = 0.01)
# We retrieve the cloud of particles associated to each generation
cloud_dfs <- lapply(res_abc$Clouds, as.data.frame)
cloud_df <- do.call(rbind, cloud_dfs)
cloud_df$generation <- sort(rep(1:length(res_abc$Clouds), popSize))
cloud_df_plot <- rbind(
data.frame(parm = cloud_df$lambda, parm_name = "lambda", generation = cloud_df$generation),
data.frame(parm = cloud_df$sigma, parm_name = "sigma", generation = cloud_df$generation)
)
cloud_df_plot$parm_name <-as.factor(cloud_df_plot$parm_name)
levels(cloud_df_plot$parm_name) <- c(lambda = TeX("$\\lambda$"), sigma = TeX("$\\sigma$"))
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=lambda, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\lambda$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,1]), color="black",
linetype="dashed")
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=mu, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\mu$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,2]), color="black",
linetype="dashed")
ggplot2::ggplot(data = cloud_df ) + ggplot2::geom_density(data = cloud_df, mapping = aes(x=sigma, color = as.factor(generation))) + ggplot2::labs(x=TeX("$\\sigma$"), y = "Density", color = "Generation") + ggplot2::theme_classic(base_size = 20) + ggplot2::theme(legend.position="right") + ggplot2::geom_vline(ggplot2::aes(xintercept=true_parms[,3]), color="black",
linetype="dashed")
